<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Musical Bubble Column - Three.js Web Renderer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0a0a2e, #16213e, #0f3460);
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        
        canvas {
            display: block;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        .control-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .control-group input {
            width: 100px;
            padding: 5px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        #status-bar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            color: white;
            font-size: 12px;
        }
        
        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .status-value {
            font-size: 18px;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .connection-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 10px;
        }
        
        .connected { background-color: #4CAF50; }
        .disconnected { background-color: #f44336; }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div>ğŸµ Musical Bubble Column</div>
        <div style="font-size: 14px; margin-top: 10px;">Connecting to WebSocket...</div>
    </div>
    
    <div id="ui" style="display: none;">
        <div id="info">
            <div><strong>ğŸµ Musical Bubble Column</strong></div>
            <div style="margin-top: 10px;">
                <div>WebGL Renderer: <span id="webgl-version">Loading...</span></div>
                <div>Quality: <span id="quality">High</span></div>
                <div>Max Particles: <span id="max-particles">50000</span></div>
            </div>
        </div>
        
        <div id="controls">
            <div class="control-group">
                <label>Camera Distance</label>
                <input type="range" id="camera-distance" min="30" max="150" value="60">
            </div>
            <div class="control-group">
                <label>Particle Size</label>
                <input type="range" id="particle-scale" min="0.5" max="3.0" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <label>Animation Speed</label>
                <input type="range" id="anim-speed" min="0.1" max="2.0" step="0.1" value="1.0">
            </div>
        </div>
        
        <div id="status-bar">
            <div class="status-item">
                <div>Connection</div>
                <div class="status-value">
                    <span id="connection-status">Connecting</span>
                    <span class="connection-dot disconnected" id="connection-dot"></span>
                </div>
            </div>
            <div class="status-item">
                <div>FPS</div>
                <div class="status-value" id="fps-counter">0</div>
            </div>
            <div class="status-item">
                <div>Particles</div>
                <div class="status-value" id="particle-count">0</div>
            </div>
            <div class="status-item">
                <div>Frame</div>
                <div class="status-value" id="frame-counter">0</div>
            </div>
            <div class="status-item">
                <div>Latency</div>
                <div class="status-value" id="latency">0ms</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, particles = [];
        let ws;
        let stats = {
            fps: 0,
            frameCount: 0,
            lastTime: 0,
            particleCount: 0,
            latency: 0
        };
        
        // æ§åˆ¶å‚æ•°
        let controls = {
            cameraDistance: 60,  // å‡å°‘é»˜è®¤è·ç¦»ï¼Œè®©å†…å®¹æ›´å¤§
            particleScale: 1.0,
            animationSpeed: 1.0
        };

        // åˆå§‹åŒ–Three.js
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0, 0, 60/255);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, controls.cameraDistance);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);
            
            // æŸ”å’Œå…‰ç…§ç³»ç»Ÿ
            const ambientLight = new THREE.AmbientLight(0x404080, 0.4); // å¢åŠ ç¯å¢ƒå…‰
            scene.add(ambientLight);
            
            // ä¸»å…‰æº - é™ä½å¼ºåº¦
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // è¡¥å……å…‰æº - é™ä½å¼ºåº¦
            const pointLight1 = new THREE.PointLight(0x88ccff, 0.3, 100);
            pointLight1.position.set(-20, 10, 20);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0xffcc88, 0.2, 100);
            pointLight2.position.set(20, -10, 20);
            scene.add(pointLight2);
            
            // æ˜¾ç¤ºWebGLä¿¡æ¯
            updateWebGLInfo();
            
            // è¿æ¥WebSocket
            connectWebSocket();
            
            // è®¾ç½®æ§åˆ¶å™¨
            setupControls();
            
            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
        }
        
        // æ˜¾ç¤ºWebGLä¿¡æ¯
        function updateWebGLInfo() {
            const gl = renderer.getContext();
            const version = gl.getParameter(gl.VERSION);
            document.getElementById('webgl-version').textContent = version;
        }
        
        // WebSocketè¿æ¥
        function connectWebSocket() {
            const wsUrl = 'ws://localhost:8765';
            console.log('Connecting to:', wsUrl);
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = function() {
                console.log('WebSocketè¿æ¥æˆåŠŸ');
                updateConnectionStatus('Connected', true);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('ui').style.display = 'block';
            };
            
            ws.onmessage = function(event) {
                const startTime = performance.now();
                const data = JSON.parse(event.data);
                handleMessage(data);
                stats.latency = Math.round(performance.now() - startTime);
            };
            
            ws.onclose = function() {
                console.log('WebSocketè¿æ¥æ–­å¼€');
                updateConnectionStatus('Disconnected', false);
                setTimeout(connectWebSocket, 2000); // 2ç§’åé‡è¿
            };
            
            ws.onerror = function(error) {
                console.error('WebSocketé”™è¯¯:', error);
                updateConnectionStatus('Error', false);
            };
        }
        
        // æ›´æ–°è¿æ¥çŠ¶æ€
        function updateConnectionStatus(status, connected) {
            document.getElementById('connection-status').textContent = status;
            const dot = document.getElementById('connection-dot');
            dot.className = `connection-dot ${connected ? 'connected' : 'disconnected'}`;
        }
        
        // å¤„ç†æœåŠ¡å™¨æ¶ˆæ¯
        function handleMessage(data) {
            switch(data.type) {
                case 'render_frame':
                    updateParticles(data.data.particles);
                    updateCamera(data.data.camera);
                    document.getElementById('frame-counter').textContent = data.frame_id || 0;
                    break;
                    
                case 'settings_update':
                case 'settings':
                    updateSettings(data.data);
                    break;
                    
                case 'clear_scene':
                    clearScene();
                    break;
            }
        }
        
        // ç²’å­æ± ç®¡ç†
        let particlePool = [];
        let maxPoolSize = 1000;
        
        // è·å–æˆ–åˆ›å»ºç²’å­
        function getParticleFromPool() {
            if (particlePool.length > 0) {
                return particlePool.pop();
            }
            return null;
        }
        
        // å›æ”¶ç²’å­åˆ°æ± 
        function returnParticleToPool(particle) {
            if (particlePool.length < maxPoolSize) {
                scene.remove(particle.mesh);
                particlePool.push(particle);
            } else {
                // æ± æ»¡äº†ï¼Œç›´æ¥é‡Šæ”¾èµ„æº
                scene.remove(particle.mesh);
                particle.geometry.dispose();
                particle.material.dispose();
            }
        }
        
        // åˆ›å»ºé«˜è´¨é‡ç²’å­
        function createBeautifulParticle(p, index) {
            const size = Math.max(p.size * 0.008 * controls.particleScale, 0.05); // ç¨å¾®å°ä¸€ç‚¹
            
            // ä½¿ç”¨æ›´é«˜è´¨é‡çš„å‡ ä½•ä½“
            const geometry = new THREE.SphereGeometry(size, 12, 8); // å¢åŠ ç»†åˆ†
            
            let material;
            if (p.type === 'light') {
                // ç¯å…‰ç²’å­ - å‘å…‰æ•ˆæœ
                material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(p.color[0], p.color[1], p.color[2]),
                    opacity: Math.min(p.color[3] * 1.2, 1.0),
                    transparent: true,
                    emissive: new THREE.Color(p.color[0] * 0.6, p.color[1] * 0.4, p.color[2] * 0.2)
                });
            } else if (p.type === 'lampshade') {
                // ç¯ç½© - æš—è‰²ä¸é€æ˜
                material = new THREE.MeshLambertMaterial({
                    color: new THREE.Color(0.1, 0.1, 0.1),
                    opacity: 0.9,
                    transparent: true
                });
            } else {
                // æ™®é€šæ°”æ³¡ - æŸ”å’ŒåŠé€æ˜æ•ˆæœ
                material = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(p.color[0], p.color[1], p.color[2]),
                    opacity: p.color[3] * 0.7,
                    transparent: true,
                    shininess: 20,  // é™ä½å…‰æ³½åº¦ï¼ˆåŸæ¥100ï¼‰
                    specular: new THREE.Color(0.2, 0.2, 0.3),  // å‡å¼±é•œé¢åå°„ï¼ˆåŸæ¥0.8, 0.8, 1.0ï¼‰
                    emissive: new THREE.Color(p.color[0] * 0.05, p.color[1] * 0.05, p.color[2] * 0.1)  // å‡å¼±å‘å…‰
                });
            }
            
            const mesh = new THREE.Mesh(geometry, material);
            // ä¿®æ­£åæ ‡ç³»ï¼šè®©æ°”æ³¡æŸ±å‚ç›´æ˜¾ç¤º (åŸæ¥çš„Zè½´æ˜ å°„åˆ°Yè½´)ï¼Œå¹¶å‘ä¸‹ç§»åŠ¨
            mesh.position.set(p.position[0] * 0.08, p.position[2] * 0.08 - 15, -p.position[1] * 0.08);
            
            // ç¨³å®šçš„åŠ¨ç”»æ•°æ®ï¼ˆå‡å°‘é—ªçƒï¼‰
            mesh.userData = {
                originalPos: {
                    x: p.position[0] * 0.08,
                    y: p.position[2] * 0.08 - 15,  // Z -> Y (å‚ç›´) å¹¶å‘ä¸‹ç§»åŠ¨
                    z: -p.position[1] * 0.08  // Y -> -Z (æ·±åº¦)
                },
                particleId: p.id || index,
                time: (p.id || index) * 0.1, // åŸºäºIDçš„ç¨³å®šæ—¶é—´åç§»
                amplitude: size * 0.5,
                type: p.type
            };
            
            return {
                mesh: mesh,
                geometry: geometry,
                material: material,
                data: p
            };
        }
        
        // æ›´æ–°ç²’å­ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼Œå‡å°‘é—ªçƒï¼‰
        function updateParticles(particleData) {
            // å›æ”¶æ‰€æœ‰æ—§ç²’å­
            particles.forEach(p => returnParticleToPool(p));
            particles = [];
            
            // åˆ›å»ºæ–°ç²’å­
            particleData.forEach((p, index) => {
                try {
                    const particle = createBeautifulParticle(p, index);
                    scene.add(particle.mesh);
                    particles.push(particle);
                } catch (error) {
                    console.warn('åˆ›å»ºç²’å­å¤±è´¥:', error);
                }
            });
            
            stats.particleCount = particles.length;
            document.getElementById('particle-count').textContent = stats.particleCount;
        }
        
        // æ›´æ–°ç›¸æœº
        function updateCamera(cameraData) {
            if (!cameraData) return;
            
            // ç®€åŒ–çš„ç›¸æœºæ§åˆ¶
            camera.position.setLength(controls.cameraDistance);
            camera.lookAt(0, 0, 0);
        }
        
        // æ›´æ–°è®¾ç½®
        function updateSettings(settings) {
            if (settings.background_color) {
                scene.background = new THREE.Color(
                    settings.background_color[0],
                    settings.background_color[1], 
                    settings.background_color[2]
                );
            }
            
            if (settings.max_particles) {
                document.getElementById('max-particles').textContent = settings.max_particles;
            }
            
            if (settings.particle_quality) {
                document.getElementById('quality').textContent = settings.particle_quality;
            }
        }
        
        // æ¸…ç©ºåœºæ™¯
        function clearScene() {
            particles.forEach(p => {
                scene.remove(p.mesh);
                p.geometry.dispose();
                p.material.dispose();
            });
            particles = [];
            stats.particleCount = 0;
            document.getElementById('particle-count').textContent = 0;
        }
        
        // è®¾ç½®æ§åˆ¶å™¨
        function setupControls() {
            document.getElementById('camera-distance').addEventListener('input', (e) => {
                controls.cameraDistance = parseFloat(e.target.value);
            });
            
            document.getElementById('particle-scale').addEventListener('input', (e) => {
                controls.particleScale = parseFloat(e.target.value);
            });
            
            document.getElementById('anim-speed').addEventListener('input', (e) => {
                controls.animationSpeed = parseFloat(e.target.value);
            });
        }
        
        // æ¸²æŸ“å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            // FPSè®¡ç®—
            const currentTime = performance.now();
            stats.frameCount++;
            
            if (currentTime - stats.lastTime >= 1000) {
                stats.fps = Math.round(stats.frameCount * 1000 / (currentTime - stats.lastTime));
                document.getElementById('fps-counter').textContent = stats.fps;
                document.getElementById('latency').textContent = stats.latency + 'ms';
                stats.frameCount = 0;
                stats.lastTime = currentTime;
            }
            
            // æ›´ç¨³å®šçš„ç²’å­åŠ¨ç”»ï¼ˆå‡å°‘é—ªçƒï¼‰
            particles.forEach(p => {
                if (p.mesh.userData && p.mesh.userData.type === 'bubble') {
                    p.mesh.userData.time += 0.005 * controls.animationSpeed; // æ›´æ…¢çš„åŠ¨ç”»
                    const offset = Math.sin(p.mesh.userData.time) * p.mesh.userData.amplitude * 0.3;
                    p.mesh.position.y = p.mesh.userData.originalPos.y + offset; // å‚ç›´æµ®åŠ¨
                    
                    // è½»å¾®çš„å·¦å³æ‘†åŠ¨
                    p.mesh.position.x = p.mesh.userData.originalPos.x + Math.sin(p.mesh.userData.time * 0.7) * 0.1;
                }
            });
            
            // ç›¸æœºæ°´å¹³ç¯ç»•å‚ç›´çš„æ°”æ³¡æŸ± - ç»•Yè½´æ—‹è½¬
            const angle = currentTime * 0.0005; // æ—‹è½¬é€Ÿåº¦
            camera.position.x = Math.cos(angle) * controls.cameraDistance;
            camera.position.z = Math.sin(angle) * controls.cameraDistance; 
            camera.position.y = 5; // ç¨å¾®é«˜ä¸€ç‚¹è§‚å¯Ÿæ°”æ³¡æŸ±
            camera.lookAt(0, -10, 0); // è§‚å¯Ÿç‚¹å‘ä¸‹ï¼Œå¯¹å‡†æ°”æ³¡æŸ±ä¸­å¿ƒ
            
            renderer.render(scene, camera);
        }
        
        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // é”™è¯¯å¤„ç†
        window.addEventListener('error', function(e) {
            console.error('é¡µé¢é”™è¯¯:', e.error);
        });
        
        // å¯åŠ¨åº”ç”¨
        console.log('ğŸµ Musical Bubble Column - Three.js Renderer');
        console.log('Initializing WebGL renderer...');
        init();
    </script>
</body>
</html>
